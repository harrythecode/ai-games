
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Shooting Star</title>
<style>
  body { background-color: #999; margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
  #gameCanvas { background: #f0f0f0; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<audio id="bgm" loop>
  <source src="bgm.mp3" type="audio/mp3">
</audio>
<audio id="shootSound">
  <source src="shoot.mp3" type="audio/mp3">
</audio>
<script>
const canvas = document.getElementById('gameCanvas');
const bgm = document.getElementById('bgm');
const shootSound = document.getElementById('shootSound');
canvas.width = 400;
canvas.height = 800;
const ctx = canvas.getContext('2d');
const backgroundImage = new Image();
backgroundImage.src = 'bg.png'; // ç”»åƒã®ãƒ‘ã‚¹ã‚’è¨­å®š

backgroundImage.onload = function() {
  ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
  updateGame(); // èƒŒæ™¯ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚ŒãŸå¾Œã«ã‚²ãƒ¼ãƒ ã®æ›´æ–°ã‚’é–‹å§‹
};

let gameStarted = false;
let gamePaused = false;
let player, enemies, bullets, powerUps, score, enemySpeed, gameOver, keys, lastShotTime, shotInterval, stageLevel, stageTime, stageDuration;

function startGame() {
  if (gameStarted) return; // ã‚²ãƒ¼ãƒ ãŒæ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
  gameStarted = true;
  resetGame();
  resumeGame();
}

function pauseGame() {
  gamePaused = true;
  bgm.pause();
}

function resumeGame() {
  if (gameOver) return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®å ´åˆã¯å†é–‹ã—ãªã„
  gamePaused = false;
  bgm.play();
  requestAnimationFrame(updateGame); // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’å†é–‹
}
// ã‚²ãƒ¼ãƒ é–‹å§‹ã®ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
document.addEventListener('click', startGame);
document.addEventListener('keydown', startGame);
window.addEventListener('blur', pauseGame);
window.addEventListener('focus', resumeGame);


function resetGame() {
  player = { x: canvas.width / 2, y: canvas.height - 100, width: 40, height: 40, color: "#00FF00", power: 5, life: 3, bulletCount: 1, bulletLines: 1, speed: 1 };
  enemies = [];
  bullets = [];
  powerUps = [];
  score = 0;
  enemySpeed = 1;
  gameOver = false;
  keys = {};
  lastShotTime = 0;
  shotInterval = 500;
  stageLevel = 1;
  stageTime = 0; // ã‚¹ãƒ†ãƒ¼ã‚¸ã”ã¨ã®çµŒéæ™‚é–“
  stageDuration = 60; // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰
}

resetGame();

function createEnemy() {
  let size = Math.round(Math.random() * 70 + 60) * stageLevel * 0.4;
  let enemy = {
    x: Math.round(Math.random() * (canvas.width - size)),
    y: -size,
    width: size,
    height: size,
    color: "#FF0000",
    hp: Math.round(size * 2 * stageLevel * 0.5)
  };
  enemies.push(enemy);
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function createPowerUp() {
  // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®å¤šæ§˜åŒ–
  let effectTypes = ['power', 'bulletCount', 'bulletLines', 'speed'];
  let margin = 10; // ã‚¢ã‚¤ãƒ†ãƒ é–“ã®ãƒãƒ¼ã‚¸ãƒ³
  let powerUpWidth = (canvas.width / 2) - margin; // ãƒãƒ¼ã‚¸ãƒ³ã‚’è€ƒæ…®ã—ãŸå¹…

  for (let i = 0; i < 2; i++) {
    let effectType = effectTypes[Math.floor(Math.random() * effectTypes.length)];
    let operation = Math.random() < 0.5 ? '+' : '-';
    let effectAmount = Math.floor(getRandomInt(stageLevel) + 3);

    let powerUp = {
      x: i * (powerUpWidth + margin) + margin / 2, // å·¦ã¾ãŸã¯å³å´ã«é…ç½®
      y: -50,
      width: powerUpWidth,
      height: 50,
      color: operation === '+' ? "rgba(0, 0, 255, 0.5)" : "rgba(255, 0, 0, 0.5)",
      effectType: effectType,
      operation: operation,
      effectAmount: effectAmount
    };
    powerUps.push(powerUp);
  }
}

setInterval(createEnemy, 2000);
setInterval(createPowerUp, 10000);

function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawEnemies() {
  enemies.forEach(enemy => {
    ctx.fillStyle = enemy.color;
    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    ctx.fillStyle = "#000";
    ctx.fillText(enemy.hp, enemy.x, enemy.y - 5);
  });
}

function drawBullets() {
  bullets.forEach(bullet => {
    ctx.fillStyle = bullet.color;
    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
  });
}

// ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®æç”»
function drawPowerUps() {
  powerUps.forEach(powerUp => {
    ctx.fillStyle = powerUp.color;
    ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);

    ctx.fillStyle = "#000";
    ctx.font = "16px Arial";
    let emoji = getEmoji(powerUp.effectType);
    ctx.fillText(emoji + powerUp.operation + powerUp.effectAmount, powerUp.x + 10, powerUp.y + 30);
  });
}

// åŠ¹æœã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸçµµæ–‡å­—ã‚’è¿”ã™é–¢æ•°
function getEmoji(effectType) {
  switch (effectType) {
    case 'power':
      return 'ğŸ’ª';
    case 'bulletCount':
      return 'ğŸ”«';
    case 'bulletLines':
      return 'ğŸ’£';
    case 'speed':
      return 'ğŸ›¼';
    default:
      return '';
  }
}

function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height); // èƒŒæ™¯ç”»åƒã‚’æç”»
}

function shoot() {
  const now = Date.now();
  const dynamicShotInterval = Math.max(100, shotInterval - player.speed * 2);
  if (keys[" "] && !gameOver && now - lastShotTime > dynamicShotInterval) {
    // å¼¾ã®é–“éš”ã‚’è¨ˆç®—
    const spacing = (player.width - (player.bulletLines * 5 * player.bulletCount)) / (player.bulletCount + 1);
    for (let i = 0; i < player.bulletCount; i++) {
      // å¼¾ã®å¹…ã‚’bulletLinesã«åŸºã¥ã„ã¦è¨­å®š
      let bulletWidth = player.bulletLines * 5; // æ¨ªå¹…ã®åŸºæœ¬å˜ä½ã‚’5ã¨ã™ã‚‹
      let bulletHeight = 10;
      // å¼¾ã®Xåº§æ¨™ã‚’èª¿æ•´ã—ã¦è¤‡æ•°ã®å¼¾ã‚’æ¨ªã«ä¸¦ã¹ã‚‹
      let bulletX = player.x + (spacing + bulletWidth) * i + spacing;
      // å¼¾ã®Yåº§æ¨™ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸Šç«¯ã‹ã‚‰ã«ä¿®æ­£
      let bulletY = player.y - bulletHeight;
      let bullet = {
        x: bulletX,
        y: bulletY,
        width: bulletWidth,
        height: bulletHeight,
        color: "#FFFF00",
        power: player.power
      };
      bullets.push(bullet);
    }
    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰å†ç”Ÿ
    shootSound.currentTime = 0;
    shootSound.play();
    lastShotTime = now;
  }
}

function updatePositions() {
  enemies.forEach(enemy => {
    enemy.y += enemySpeed;
  });
  bullets.forEach(bullet => {
    bullet.y -= 5;
  });
  powerUps.forEach(powerUp => {
    powerUp.y += 1 + (0.3*stageLevel);
  });
}
function handleCollisions() {
  // å¼¾ã¨æ•µã®è¡çª
  bullets.forEach((bullet, bIndex) => {
    enemies.forEach((enemy, eIndex) => {
      if (isColliding(bullet, enemy)) {
        enemy.hp -= bullet.power;
        if (enemy.hp <= 0) {
          if (enemy.isBoss) { // ãƒœã‚¹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
            score += 100; // ãƒœã‚¹ã‚’å€’ã—ãŸã‚‰ã‚¹ã‚³ã‚¢ã‚’+100
          } else {
            score += 10; // é€šå¸¸ã®æ•µã‚’å€’ã—ãŸå ´åˆã¯ã‚¹ã‚³ã‚¢ã‚’+10
          }
          enemies.splice(eIndex, 1);
          enemySpeed += 0.05; // æ•µã®é€Ÿåº¦ã‚’å¾ã€…ã«ä¸Šã’ã‚‹
        }
        bullets.splice(bIndex, 1); // å¼¾ã‚’å‰Šé™¤
      }
    });
  });

  // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡çªå‡¦ç†
  powerUps.forEach((powerUp, pIndex) => {
    if (isColliding(powerUp, player)) {
      applyPowerUp(powerUp);
      // å–å¾—ã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
      powerUps.splice(pIndex, 1);
    }
  });

  // æ•µã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡çª
  enemies.forEach((enemy, eIndex) => {
    if (isColliding(enemy, player)) {
      player.life--;
      if (player.life <= 0) {
        gameOver = true;
      }
      enemies.splice(eIndex, 1);
    }
  });
}

// ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã®åŠ¹æœã‚’é©ç”¨ã™ã‚‹é–¢æ•°
function applyPowerUp(powerUp) {
  let effectChange = powerUp.operation === '+' ? powerUp.effectAmount : -powerUp.effectAmount;
  switch (powerUp.effectType) {
    case 'power':
      player.power = Math.max(1, player.power + effectChange);
      break;
    case 'bulletCount':
      player.bulletCount = Math.max(1, player.bulletCount + effectChange);
      break;
    case 'bulletLines':
      player.bulletLines = Math.max(1, player.bulletLines + effectChange);
      break;
    case 'speed':
      player.speed = Math.max(1, player.speed + effectChange);
      break;
  }
}

function isColliding(rect1, rect2) {
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.height + rect1.y > rect2.y;
}

function removeOffscreenEnemies() {
  enemies = enemies.filter(enemy => enemy.y < canvas.height);
}

function removeDestroyedBullets() {
  bullets = bullets.filter(bullet => bullet.y > 0);
}

function removeUsedPowerUps() {
  powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height);
}

function drawScore() {
  ctx.fillStyle = "#000";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 10, 30); // ã‚¹ã‚³ã‚¢è¡¨ç¤ºã®ä½ç½®å¤‰æ›´
  ctx.fillText("Stage: " + stageLevel, 10, 50); // ã‚¹ãƒ†ãƒ¼ã‚¸è¡¨ç¤ºã®ä½ç½®å¤‰æ›´
  ctx.fillText("Life: " + player.life, canvas.width - 100, 30); // ãƒ©ã‚¤ãƒ•è¡¨ç¤ºã®ä½ç½®å¤‰æ›´

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¡¨ç¤º
  ctx.font = "12px Arial";
  const statusText = `ğŸ’ª${player.power} / ğŸ”«${player.bulletCount} / ğŸ’£${player.bulletLines} / ğŸ›¼${player.speed}`;
  const textWidth = ctx.measureText(statusText).width;
  ctx.fillText(statusText, (canvas.width - textWidth) / 2, canvas.height - 20); // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸‹éƒ¨ä¸­å¤®ã«é…ç½®
}

function handleInput() {
  if(keys["ArrowLeft"]) player.x = Math.max(0, player.x - (1 + player.speed*0.2));
  if(keys["ArrowRight"]) player.x = Math.min(canvas.width - player.width, player.x + (1 + player.speed*0.2));
  shoot(); // Move shoot function here to allow shooting while moving
}

function updateGame() {
  if (gamePaused) return; // ã‚²ãƒ¼ãƒ ãŒä¸€æ™‚åœæ­¢ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯æ›´æ–°ã‚’åœæ­¢

  if (!gameStarted) {
    clearCanvas();
    ctx.fillStyle = "#000";
    ctx.font = "24px Arial";
    ctx.fillText("Click or Press any key to Start", canvas.width / 2 - 180, canvas.height / 2);
    return; // ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã“ã“ã§å‡¦ç†ã‚’çµ‚äº†
  }

  if(!gameOver) {
    bgm.play();
    handleInput();
    updatePositions();
    handleCollisions();
    removeOffscreenEnemies();
    removeDestroyedBullets();
    removeUsedPowerUps();
    clearCanvas();
    drawPlayer();
    drawEnemies();
    drawBullets();
    drawPowerUps();
    drawScore();
    // ã‚¹ãƒ†ãƒ¼ã‚¸æ™‚é–“ã®æ›´æ–°
    stageTime += 1 / 60; // 60FPSã‚’æƒ³å®š
    if (stageTime > stageDuration) {
        stageLevel++;
        stageTime = 0;
        enemySpeed += 0.05; // æ•µã®é€Ÿåº¦ã‚’å¢—åŠ 
        spawnBoss();
    }
  } else {
    bgm.pause();
    ctx.fillStyle = "#000";
    ctx.font = "24px Arial";
    ctx.fillText("Game Over", canvas.width / 2 - 80, canvas.height / 2);
    ctx.fillText("Press Space to Restart", canvas.width / 2 - 130, canvas.height / 2 + 40);
  }
  requestAnimationFrame(updateGame);
}

// ãƒœã‚¹ã®ç”Ÿæˆé–¢æ•°
function spawnBoss() {
  // ãƒœã‚¹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®š
  let boss = {
    x: 0,
    y: -50,
    width: canvas.width,
    height: 50,
    speed: 1 + ( 0.1 * stageLevel ),
    hp: 30 * stageLevel, // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸHP
    isBoss: true
  };
  // ãƒœã‚¹ã‚’æ•µãƒªã‚¹ãƒˆã«è¿½åŠ 
  enemies.push(boss);
}

document.addEventListener('keydown', event => {
  keys[event.key] = true;
  shoot();
  if (gameOver && event.key === " ") {
    resetGame();
  }
});

document.addEventListener('keyup', event => {
  keys[event.key] = false;
});

updateGame();

</script>
</body>
</html>